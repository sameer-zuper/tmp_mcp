import { MCPServer } from "@mastra/mcp";
import { mastra } from "../index";
import { z } from "zod";
import { resources } from "./resources";
import { prompts } from "./prompts";

// Default fallback values from environment (for testing/development)
const DEFAULT_ZUPER_API_KEY = process.env.ZUPER_API_KEY || "";
const DEFAULT_ZUPER_BASE_URL = process.env.ZUPER_BASE_URL || "";

async function makeZuperRequest(
  endpoint: string,
  apiKey: string,
  baseUrl: string,
  method: string = "GET",
  body?: any
) {
  const url = `${baseUrl}${endpoint}`;
  const options: RequestInit = {
    method,
    headers: {
      "x-api-key": apiKey,
      "Content-Type": "application/json",
    },
  };

  if (body && method !== "GET") {
    options.body = JSON.stringify(body);
  }

  const response = await fetch(url, options);
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Zuper API error (${response.status}): ${errorText || response.statusText}`);
  }

  return response.json();
}

// Common parameter schema for API credentials
// These are optional - if not provided, will use defaults from environment
const apiCredentialsSchema = z.object({
  apiKey: z
    .string()
    .optional()
    .describe("Zuper API key for authentication (x-api-key header). If not provided, uses default from environment."),
  baseUrl: z
    .string()
    .optional()
    .describe("Zuper base URL (e.g., https://us.zuperpro.com). If not provided, uses default from environment."),
});

export const mcp = new MCPServer({
  name: "zuper-fsm-server",
  version: "0.1.0",
  mastra,
  resources,
  prompts,
  tools: {
    // Job Management Tools
    createJob: {
      description:
        "Create a new job/work order in Zuper FSM with customer, property, and service details",
      parameters: apiCredentialsSchema.extend({
        customerUid: z
          .string()
          .describe("Unique identifier of the customer for this job"),
        jobTitle: z.string().describe("Title or name of the job"),
        jobDescription: z.string().optional().describe("Description of the job"),
        propertyUid: z
          .string()
          .optional()
          .describe("Property/location identifier for the job"),
        scheduledStartTime: z
          .string()
          .optional()
          .describe("Scheduled start time in ISO 8601 format"),
        scheduledEndTime: z
          .string()
          .optional()
          .describe("Scheduled end time in ISO 8601 format"),
        priority: z
          .enum(["low", "medium", "high", "urgent"])
          .optional()
          .describe("Priority level of the job"),
        assignedTo: z
          .array(z.string())
          .optional()
          .describe("Array of user UIDs to assign to this job"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, ...jobData } = params;
        const result = await makeZuperRequest("/api/jobs", apiKey, baseUrl, "POST", jobData);
        return {
          status: "success",
          data: result,
          message: `Job created successfully with ID: ${result.data?.uid}`,
        };
      },
    },

    getJob: {
      description: "Retrieve details of a specific job by its UID",
      parameters: apiCredentialsSchema.extend({
        jobUid: z.string().describe("Unique identifier of the job to retrieve"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, jobUid } = params;
        const result = await makeZuperRequest(`/api/jobs/${jobUid}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
        };
      },
    },

    listJobs: {
      description:
        "List all jobs with optional filtering by status, date range, or customer",
      parameters: apiCredentialsSchema.extend({
        status: z
          .enum([
            "scheduled",
            "in_progress",
            "completed",
            "cancelled",
            "on_hold",
          ])
          .optional()
          .describe("Filter jobs by status"),
        page: z.number().optional().default(1).describe("Page number for pagination"),
        limit: z.number().optional().default(50).describe("Number of results per page"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, status, page = 1, limit = 50 } = params;
        const queryParams = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        });

        if (status) {
          queryParams.append("status", status);
        }

        const result = await makeZuperRequest(`/api/jobs?${queryParams.toString()}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
          count: result.data?.length || 0,
        };
      },
    },

    updateJob: {
      description: "Update an existing job with new information",
      parameters: apiCredentialsSchema.extend({
        jobUid: z.string().describe("Unique identifier of the job to update"),
        updates: z
          .object({
            jobTitle: z.string().optional(),
            jobDescription: z.string().optional(),
            status: z
              .enum([
                "scheduled",
                "in_progress",
                "completed",
                "cancelled",
                "on_hold",
              ])
              .optional(),
            priority: z.enum(["low", "medium", "high", "urgent"]).optional(),
            scheduledStartTime: z.string().optional(),
            scheduledEndTime: z.string().optional(),
          })
          .describe("Fields to update"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, jobUid, updates } = params;
        const result = await makeZuperRequest(
          `/api/jobs/${jobUid}`,
          apiKey,
          baseUrl,
          "PUT",
          updates
        );
        return {
          status: "success",
          data: result,
          message: `Job ${jobUid} updated successfully`,
        };
      },
    },

    // Customer Management Tools
    createCustomer: {
      description: "Create a new customer in Zuper FSM",
      parameters: apiCredentialsSchema.extend({
        firstName: z.string().describe("Customer's first name"),
        lastName: z.string().describe("Customer's last name"),
        email: z.string().email().optional().describe("Customer's email address"),
        phone: z.string().optional().describe("Customer's phone number"),
        companyName: z.string().optional().describe("Company name if business customer"),
        address: z
          .object({
            street: z.string().optional(),
            city: z.string().optional(),
            state: z.string().optional(),
            zipCode: z.string().optional(),
            country: z.string().optional(),
          })
          .optional()
          .describe("Customer address details"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, ...customerData } = params;
        const result = await makeZuperRequest("/api/customers", apiKey, baseUrl, "POST", customerData);
        return {
          status: "success",
          data: result,
          message: `Customer created successfully with ID: ${result.data?.uid}`,
        };
      },
    },

    getCustomer: {
      description: "Retrieve details of a specific customer by UID",
      parameters: apiCredentialsSchema.extend({
        customerUid: z
          .string()
          .describe("Unique identifier of the customer to retrieve"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, customerUid } = params;
        const result = await makeZuperRequest(
          `/api/customers/${customerUid}`,
          apiKey,
          baseUrl
        );
        return {
          status: "success",
          data: result,
        };
      },
    },

    listCustomers: {
      description: "List all customers with pagination",
      parameters: apiCredentialsSchema.extend({
        page: z.number().optional().default(1).describe("Page number for pagination"),
        limit: z.number().optional().default(50).describe("Number of results per page"),
        search: z
          .string()
          .optional()
          .describe("Search customers by name, email, or phone"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, page = 1, limit = 50, search } = params;
        const queryParams = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        });

        if (search) {
          queryParams.append("search", search);
        }

        const result = await makeZuperRequest(
          `/api/customers?${queryParams.toString()}`,
          apiKey,
          baseUrl
        );
        return {
          status: "success",
          data: result,
          count: result.data?.length || 0,
        };
      },
    },

    // Invoice Management Tools
    createInvoice: {
      description: "Create a new invoice for a job or customer",
      parameters: apiCredentialsSchema.extend({
        jobUid: z
          .string()
          .optional()
          .describe("Job UID this invoice is associated with"),
        customerUid: z.string().describe("Customer UID for this invoice"),
        invoiceDate: z
          .string()
          .describe("Invoice date in ISO 8601 format"),
        dueDate: z
          .string()
          .optional()
          .describe("Payment due date in ISO 8601 format"),
        lineItems: z
          .array(
            z.object({
              description: z.string(),
              quantity: z.number(),
              unitPrice: z.number(),
              taxRate: z.number().optional(),
            })
          )
          .describe("Line items for the invoice"),
        notes: z.string().optional().describe("Additional notes for the invoice"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, ...invoiceData } = params;
        const result = await makeZuperRequest("/api/invoices", apiKey, baseUrl, "POST", invoiceData);
        return {
          status: "success",
          data: result,
          message: `Invoice created successfully with ID: ${result.data?.uid}`,
        };
      },
    },

    getInvoice: {
      description: "Retrieve details of a specific invoice by UID",
      parameters: apiCredentialsSchema.extend({
        invoiceUid: z
          .string()
          .describe("Unique identifier of the invoice to retrieve"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, invoiceUid } = params;
        const result = await makeZuperRequest(
          `/api/invoices/${invoiceUid}`,
          apiKey,
          baseUrl
        );
        return {
          status: "success",
          data: result,
        };
      },
    },

    listInvoices: {
      description: "List all invoices with optional filtering",
      parameters: apiCredentialsSchema.extend({
        status: z
          .enum(["draft", "sent", "paid", "overdue", "cancelled"])
          .optional()
          .describe("Filter invoices by status"),
        customerUid: z
          .string()
          .optional()
          .describe("Filter by specific customer"),
        page: z.number().optional().default(1).describe("Page number for pagination"),
        limit: z.number().optional().default(50).describe("Number of results per page"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, status, customerUid, page = 1, limit = 50 } = params;
        const queryParams = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        });

        if (status) {
          queryParams.append("status", status);
        }
        if (customerUid) {
          queryParams.append("customerUid", customerUid);
        }

        const result = await makeZuperRequest(
          `/api/invoices?${queryParams.toString()}`,
          apiKey,
          baseUrl
        );
        return {
          status: "success",
          data: result,
          count: result.data?.length || 0,
        };
      },
    },

    // Property Management Tools
    createProperty: {
      description: "Create a new property/location for a customer",
      parameters: apiCredentialsSchema.extend({
        customerUid: z
          .string()
          .describe("Customer UID this property belongs to"),
        propertyName: z.string().describe("Name of the property"),
        address: z.object({
          street: z.string(),
          city: z.string(),
          state: z.string(),
          zipCode: z.string(),
          country: z.string(),
        }),
        propertyType: z
          .string()
          .optional()
          .describe("Type of property (residential, commercial, etc.)"),
        notes: z.string().optional(),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, ...propertyData } = params;
        const result = await makeZuperRequest("/api/properties", apiKey, baseUrl, "POST", propertyData);
        return {
          status: "success",
          data: result,
          message: `Property created successfully with ID: ${result.data?.uid}`,
        };
      },
    },

    getProperty: {
      description: "Retrieve details of a specific property by UID",
      parameters: apiCredentialsSchema.extend({
        propertyUid: z
          .string()
          .describe("Unique identifier of the property to retrieve"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, propertyUid } = params;
        const result = await makeZuperRequest(
          `/api/properties/${propertyUid}`,
          apiKey,
          baseUrl
        );
        return {
          status: "success",
          data: result,
        };
      },
    },

    // ========================================
    // USER MANAGEMENT TOOLS
    // ========================================

    getUser: {
      description: "Retrieve details of a specific user by UID",
      parameters: apiCredentialsSchema.extend({
        userUid: z.string().describe("Unique identifier of the user to retrieve"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, userUid } = params;
        const result = await makeZuperRequest(`/api/user/${userUid}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
        };
      },
    },

    listUsers: {
      description:
        "List all users in the organization with their details, skills, and availability",
      parameters: apiCredentialsSchema.extend({
        page: z.number().optional().default(1).describe("Page number for pagination"),
        limit: z.number().optional().default(50).describe("Number of results per page"),
        status: z
          .enum(["active", "inactive"])
          .optional()
          .describe("Filter by user status"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, page = 1, limit = 50, status } = params;
        const queryParams = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        });

        if (status) {
          queryParams.append("status", status);
        }

        const result = await makeZuperRequest(`/api/user/all?${queryParams.toString()}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
          count: result.data?.length || 0,
        };
      },
    },

    getUserSkills: {
      description: "Get the skills assigned to a specific user for job matching",
      parameters: apiCredentialsSchema.extend({
        userUid: z.string().describe("Unique identifier of the user"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, userUid } = params;
        // Note: Endpoint is /api/users/{uid}/skill (plural users, singular skill)
        const result = await makeZuperRequest(`/api/users/${userUid}/skill`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
        };
      },
    },

    // ========================================
    // TEAM MANAGEMENT TOOLS
    // ========================================

    getTeam: {
      description: "Retrieve details of a specific team by UID",
      parameters: apiCredentialsSchema.extend({
        teamUid: z.string().describe("Unique identifier of the team to retrieve"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, teamUid } = params;
        const result = await makeZuperRequest(`/api/team/${teamUid}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
        };
      },
    },

    listTeams: {
      description: "List all teams in the organization",
      parameters: apiCredentialsSchema.extend({
        page: z.number().optional().default(1).describe("Page number for pagination"),
        limit: z.number().optional().default(50).describe("Number of results per page"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, page = 1, limit = 50 } = params;
        const queryParams = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        });

        // Note: Endpoint is /api/team (singular) not /api/teams
        const result = await makeZuperRequest(`/api/team?${queryParams.toString()}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
          count: result.data?.length || 0,
        };
      },
    },

    // ========================================
    // TIMESHEET TOOLS
    // ========================================

    listTimesheets: {
      description: "Get timesheets for users within a date range to check availability",
      parameters: apiCredentialsSchema.extend({
        userUid: z.string().optional().describe("Filter by specific user"),
        startDate: z
          .string()
          .optional()
          .describe("Start date in ISO 8601 format"),
        endDate: z
          .string()
          .optional()
          .describe("End date in ISO 8601 format"),
        page: z.number().optional().default(1).describe("Page number for pagination"),
        limit: z.number().optional().default(50).describe("Number of results per page"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, userUid, startDate, endDate, page = 1, limit = 50 } = params;
        const queryParams = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        });

        if (userUid) queryParams.append("userUid", userUid);
        if (startDate) queryParams.append("startDate", startDate);
        if (endDate) queryParams.append("endDate", endDate);

        const result = await makeZuperRequest(`/api/timesheets?${queryParams.toString()}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
          count: result.data?.length || 0,
        };
      },
    },

    getTimesheetSummary: {
      description: "Get timesheet summary for a user to check working hours and availability",
      parameters: apiCredentialsSchema.extend({
        userUid: z.string().describe("User identifier"),
        startDate: z.string().describe("Start date in ISO 8601 format"),
        endDate: z.string().describe("End date in ISO 8601 format"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, userUid, startDate, endDate } = params;
        const queryParams = new URLSearchParams({
          userUid,
          startDate,
          endDate,
        });

        const result = await makeZuperRequest(`/api/timesheets/summary?${queryParams.toString()}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
        };
      },
    },

    // ========================================
    // TIME-OFF MANAGEMENT TOOLS
    // ========================================

    listTimeOffRequests: {
      description:
        "List time-off requests to check which users are unavailable for job assignment",
      parameters: apiCredentialsSchema.extend({
        userUid: z.string().optional().describe("Filter by specific user"),
        status: z
          .enum(["pending", "approved", "rejected"])
          .optional()
          .describe("Filter by request status"),
        startDate: z
          .string()
          .optional()
          .describe("Filter time-offs starting from this date"),
        endDate: z
          .string()
          .optional()
          .describe("Filter time-offs ending before this date"),
        page: z.number().optional().default(1).describe("Page number for pagination"),
        limit: z.number().optional().default(50).describe("Number of results per page"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, userUid, status, startDate, endDate, page = 1, limit = 50 } = params;
        const queryParams = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        });

        if (userUid) queryParams.append("userUid", userUid);
        if (status) queryParams.append("status", status);
        if (startDate) queryParams.append("startDate", startDate);
        if (endDate) queryParams.append("endDate", endDate);

        const result = await makeZuperRequest(`/api/timeoff?${queryParams.toString()}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
          count: result.data?.length || 0,
        };
      },
    },

    checkTimeOffAvailability: {
      description:
        "Check if a user is available during a specific date range (not on time-off)",
      parameters: apiCredentialsSchema.extend({
        userUid: z.string().describe("User identifier to check availability"),
        startDate: z.string().describe("Start date in ISO 8601 format"),
        endDate: z.string().describe("End date in ISO 8601 format"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, userUid, startDate, endDate } = params;
        const queryParams = new URLSearchParams({
          userUid,
          startDate,
          endDate,
        });

        const result = await makeZuperRequest(`/api/timeoff/availability?${queryParams.toString()}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
          available: result.available || false,
        };
      },
    },

    // ========================================
    // ASSET MANAGEMENT TOOLS
    // ========================================

    createAsset: {
      description: "Create a new asset for tracking equipment, tools, or resources",
      parameters: apiCredentialsSchema.extend({
        assetName: z.string().describe("Name of the asset"),
        assetType: z.string().optional().describe("Type/category of the asset"),
        customerUid: z
          .string()
          .optional()
          .describe("Customer this asset belongs to"),
        propertyUid: z
          .string()
          .optional()
          .describe("Property where asset is located"),
        serialNumber: z.string().optional().describe("Serial number of the asset"),
        modelNumber: z.string().optional().describe("Model number"),
        manufacturer: z.string().optional().describe("Manufacturer name"),
        installationDate: z
          .string()
          .optional()
          .describe("Installation date in ISO 8601 format"),
        warrantyExpiry: z
          .string()
          .optional()
          .describe("Warranty expiry date in ISO 8601 format"),
        notes: z.string().optional().describe("Additional notes"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, ...assetData } = params;
        const result = await makeZuperRequest("/api/assets", apiKey, baseUrl, "POST", assetData);
        return {
          status: "success",
          data: result,
          message: `Asset created successfully with ID: ${result.data?.uid}`,
        };
      },
    },

    getAsset: {
      description: "Retrieve details of a specific asset",
      parameters: apiCredentialsSchema.extend({
        assetUid: z.string().describe("Unique identifier of the asset"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, assetUid } = params;
        const result = await makeZuperRequest(`/api/assets/${assetUid}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
        };
      },
    },

    listAssets: {
      description: "List all assets with optional filtering",
      parameters: apiCredentialsSchema.extend({
        customerUid: z
          .string()
          .optional()
          .describe("Filter by customer"),
        propertyUid: z
          .string()
          .optional()
          .describe("Filter by property"),
        assetType: z.string().optional().describe("Filter by asset type"),
        page: z.number().optional().default(1).describe("Page number for pagination"),
        limit: z.number().optional().default(50).describe("Number of results per page"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, customerUid, propertyUid, assetType, page = 1, limit = 50 } = params;
        const queryParams = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        });

        if (customerUid) queryParams.append("customerUid", customerUid);
        if (propertyUid) queryParams.append("propertyUid", propertyUid);
        if (assetType) queryParams.append("assetType", assetType);

        const result = await makeZuperRequest(`/api/assets?${queryParams.toString()}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
          count: result.data?.length || 0,
        };
      },
    },

    // ========================================
    // PARTS & INVENTORY TOOLS
    // ========================================

    createPart: {
      description: "Create a new part/service item in inventory",
      parameters: apiCredentialsSchema.extend({
        partName: z.string().describe("Name of the part or service"),
        partType: z
          .enum(["part", "service"])
          .describe("Type: part for physical items, service for labor"),
        sku: z.string().optional().describe("Stock Keeping Unit (SKU)"),
        description: z.string().optional().describe("Part description"),
        unitPrice: z.number().optional().describe("Price per unit"),
        quantity: z.number().optional().describe("Available quantity in stock"),
        unit: z.string().optional().describe("Unit of measurement (e.g., pcs, hours)"),
        category: z.string().optional().describe("Part category"),
        vendor: z.string().optional().describe("Vendor/supplier name"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, ...partData } = params;
        const result = await makeZuperRequest("/api/parts", apiKey, baseUrl, "POST", partData);
        return {
          status: "success",
          data: result,
          message: `Part created successfully with ID: ${result.data?.uid}`,
        };
      },
    },

    getPart: {
      description: "Retrieve details of a specific part or service",
      parameters: apiCredentialsSchema.extend({
        partUid: z.string().describe("Unique identifier of the part"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, partUid } = params;
        const result = await makeZuperRequest(`/api/parts/${partUid}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
        };
      },
    },

    listParts: {
      description: "List all parts and services in inventory",
      parameters: apiCredentialsSchema.extend({
        partType: z
          .enum(["part", "service"])
          .optional()
          .describe("Filter by type"),
        category: z.string().optional().describe("Filter by category"),
        search: z
          .string()
          .optional()
          .describe("Search by name, SKU, or description"),
        page: z.number().optional().default(1).describe("Page number for pagination"),
        limit: z.number().optional().default(50).describe("Number of results per page"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, partType, category, search, page = 1, limit = 50 } = params;
        const queryParams = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        });

        if (partType) queryParams.append("type", partType);
        if (category) queryParams.append("category", category);
        if (search) queryParams.append("search", search);

        const result = await makeZuperRequest(`/api/parts?${queryParams.toString()}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
          count: result.data?.length || 0,
        };
      },
    },

    // ========================================
    // SERVICE CONTRACT TOOLS
    // ========================================

    createServiceContract: {
      description: "Create a new service contract for recurring maintenance or services",
      parameters: apiCredentialsSchema.extend({
        customerUid: z.string().describe("Customer identifier"),
        contractName: z.string().describe("Name of the service contract"),
        contractType: z
          .string()
          .optional()
          .describe("Type of contract (e.g., maintenance, support)"),
        startDate: z.string().describe("Contract start date in ISO 8601 format"),
        endDate: z.string().describe("Contract end date in ISO 8601 format"),
        recurringSchedule: z
          .string()
          .optional()
          .describe("Recurrence pattern (e.g., monthly, quarterly)"),
        value: z.number().optional().describe("Contract value/amount"),
        description: z.string().optional().describe("Contract description"),
        terms: z.string().optional().describe("Contract terms and conditions"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, ...contractData } = params;
        const result = await makeZuperRequest("/api/service-contracts", apiKey, baseUrl, "POST", contractData);
        return {
          status: "success",
          data: result,
          message: `Service contract created successfully with ID: ${result.data?.uid}`,
        };
      },
    },

    getServiceContract: {
      description: "Retrieve details of a specific service contract",
      parameters: apiCredentialsSchema.extend({
        contractUid: z.string().describe("Unique identifier of the service contract"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, contractUid } = params;
        const result = await makeZuperRequest(`/api/service-contracts/${contractUid}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
        };
      },
    },

    listServiceContracts: {
      description: "List all service contracts with optional filtering",
      parameters: apiCredentialsSchema.extend({
        customerUid: z
          .string()
          .optional()
          .describe("Filter by customer"),
        status: z
          .enum(["active", "expired", "cancelled"])
          .optional()
          .describe("Filter by contract status"),
        page: z.number().optional().default(1).describe("Page number for pagination"),
        limit: z.number().optional().default(50).describe("Number of results per page"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, customerUid, status, page = 1, limit = 50 } = params;
        const queryParams = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        });

        if (customerUid) queryParams.append("customerUid", customerUid);
        if (status) queryParams.append("status", status);

        const result = await makeZuperRequest(`/api/service-contracts?${queryParams.toString()}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
          count: result.data?.length || 0,
        };
      },
    },

    // ========================================
    // QUOTE MANAGEMENT TOOLS
    // ========================================

    createQuote: {
      description: "Create a new quote/estimate for a customer",
      parameters: apiCredentialsSchema.extend({
        customerUid: z.string().describe("Customer identifier"),
        jobUid: z
          .string()
          .optional()
          .describe("Associated job identifier"),
        quoteDate: z.string().describe("Quote date in ISO 8601 format"),
        validUntil: z
          .string()
          .optional()
          .describe("Quote valid until date in ISO 8601 format"),
        lineItems: z
          .array(
            z.object({
              description: z.string(),
              quantity: z.number(),
              unitPrice: z.number(),
              taxRate: z.number().optional(),
            })
          )
          .describe("Line items for the quote"),
        notes: z.string().optional().describe("Additional notes"),
        terms: z.string().optional().describe("Terms and conditions"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, ...quoteData } = params;
        const result = await makeZuperRequest("/api/quotes", apiKey, baseUrl, "POST", quoteData);
        return {
          status: "success",
          data: result,
          message: `Quote created successfully with ID: ${result.data?.uid}`,
        };
      },
    },

    getQuote: {
      description: "Retrieve details of a specific quote",
      parameters: apiCredentialsSchema.extend({
        quoteUid: z.string().describe("Unique identifier of the quote"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, quoteUid } = params;
        const result = await makeZuperRequest(`/api/quotes/${quoteUid}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
        };
      },
    },

    listQuotes: {
      description: "List all quotes with optional filtering",
      parameters: apiCredentialsSchema.extend({
        customerUid: z
          .string()
          .optional()
          .describe("Filter by customer"),
        status: z
          .enum(["draft", "sent", "accepted", "rejected", "expired"])
          .optional()
          .describe("Filter by quote status"),
        page: z.number().optional().default(1).describe("Page number for pagination"),
        limit: z.number().optional().default(50).describe("Number of results per page"),
      }),
      execute: async ({ context, runId, params }) => {
        const { apiKey = DEFAULT_ZUPER_API_KEY, baseUrl = DEFAULT_ZUPER_BASE_URL, customerUid, status, page = 1, limit = 50 } = params;
        const queryParams = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        });

        if (customerUid) queryParams.append("customerUid", customerUid);
        if (status) queryParams.append("status", status);

        const result = await makeZuperRequest(`/api/quotes?${queryParams.toString()}`, apiKey, baseUrl);
        return {
          status: "success",
          data: result,
          count: result.data?.length || 0,
        };
      },
    },
  },
});
